import sys
import re
import time

pattern_word = re.compile(r"([:\w]+)")
pattern_class = re.compile(r"(.*[\s^\(,])(::[:\w]+)([\s),].*)")
pattern_exception = re.compile(r"(\s*)(exception)(\s+\w+)(.*)")
pattern_raises = re.compile(r"(.*\s)(raises\s*\([\w:,\s]+\))(.*)")
pattern_enum = re.compile(r"\s*((?:const unsigned short|const short|const unsigned long))\s+([\w]+\s+=\s+[\w]+)\s*;\s*")
pattern_method = re.compile(r"\s*(.*\(.*\))\s*(;*)\s*")
parse_classname = re.compile(r"\s*class\s+(\w+)[\s:]+.*{.*")

defines = {
  "module"    : "namespace",
  "interface" : "class",
  "sequence"  : "std::basic_string",
  "::dom::DOMString" : "std::string",
  "::html::DOMString" : "std::string",
  "attribute" : "",
  "readonly"  : "const",
  "in"        : "",
  "boolean"   : "bool",
  "float"     : "double"
}

not_enum = 1

generated_files_head = """
/*
  DO NOT EDIT!
  This file has been generated by """ + sys.argv[0][sys.argv[0].rfind("/")+1:] + """ script.
  $Id$
*/
"""

out_idl_header = open(sys.argv[1] + "/html.h", 'w')

timestamp_guard = "" #time.strftime("%Y_%m_%d__%H_%M_%S", time.localtime())
out_idl_header.write("#ifndef __idl_header_" + timestamp_guard +"__\n")
out_idl_header.write("#define __idl_header_" + timestamp_guard +"__\n")
out_idl_header.write(generated_files_head)
out_idl_header.write("""
#include <string>
#include <v8/v8.h>

""")

def repl(m): 
    if m.group(1) in defines:
        return defines[m.group(1)]
    else:
        return m.group(1)

def with_smart_ptr(m):
    if m.group(1).startswith("::") and m.group(1).find("DOMString") == -1 :
        return " v8::Handle<v8::Value> /*" + m.group(1).strip() + "*/ "
    else:
        return m.group(1)

def fix_line(line):
    """Convert IDL line to C++"""
	
    global not_enum

    """replacing by dictionary"""
    line = pattern_word.sub(repl, line)

    """Encapsulate objects by pointer"""
    if line.find("class") == -1 and line.find("typedef") == -1 :
        line = pattern_word.sub(with_smart_ptr, line)
    """Clear raises"""
    m = pattern_raises.match(line)
    if m:
        line = m.group(1) + m.group(3)
    """Enum"""
    m = pattern_enum.match(line)
    if m:
        if not_enum:
            not_enum = 0
            line = "enum  { \n" + m.group(2)
        else:
            line = ", \n" + m.group(2) 
    else:
        if not not_enum:
            not_enum = 1
            line = " }; \n" + line + "\n";
    """Exeptions"""
    m = pattern_exception.match(line)
    if m:
        line = m.group(1) + "class" + m.group(3) + ": public std::exception " + m.group(4) + "\n"
    """Virualize methods"""
    m = pattern_method.match(line)
    if m:
        line = "virtual " + m.group(1) + " " + m.group(2) + "\n"

    lines = line.split("\n")
    for l in lines:
        m = parse_classname.match(l)
        if m:
            line += "public:\n"
            line += m.group(1) + "();\n"
            break
    return line

for line in sys.stdin:
    line = fix_line(line)
    out_idl_header.write(line)

out_idl_header.write("#endif\n\n")

out_idl_header.close()

