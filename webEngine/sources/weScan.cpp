/*
    scanServer is the web-application audit program
    Copyright (C) 2009 Andrew "Stinger" Abramov stinger911@gmail.com

    This file is part of scanServer

    scanServer is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    scanServer is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with inventoryScanner.  If not, see <http://www.gnu.org/licenses/>.
*/
#include <weLogger.h>
#include <weHelper.h>
#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string/predicate.hpp>
#include "weScan.h"

namespace webEngine {

ScanInfo::ScanInfo()
{
    startTime = posix_time::second_clock::local_time();
    finishTime = posix_time::not_a_date_time;
    pingTime = posix_time::not_a_date_time;
    status = weScanIdle;
    scanID = "";
}

ScanInfo::~ScanInfo()
{
    // nothing special at this moment
}

std::string ScanInfo::ToXml( void )
{
    string retval;
    string strData;

    retval = "";

    LOG4CXX_TRACE(iLogger::GetLogger(), "ScanInfo::ToXml");
    retval += "<scan id='" + ScreenXML(scanID) + "'>\n";
    retval += "  <object>" + ScreenXML(objectID) + "</object>\n";
    retval += "  <profile>" + ScreenXML(profileID) + "</profile>\n";
    strData = posix_time::to_simple_string(startTime);
    retval += "  <start_time>" + ScreenXML(strData) + "</start_time>\n";
    strData = posix_time::to_simple_string(finishTime);
    retval += "  <finish_time>" + ScreenXML(strData) + "</finish_time>\n";
    strData = posix_time::to_simple_string(pingTime);
    retval += "  <ping_time>" + ScreenXML(strData) + "</ping_time>\n";
    retval += "  <status>" + boost::lexical_cast<string>(status) + "</status>\n";
    retval += "  <scan_data_list>\n";
    for (int i = 0; i < scan_data.size(); i++) {
        retval += scan_data[i]->ToXml();
    }
    retval += "  </scan_data_list>\n";
    retval += "</scan>\n";
    return retval;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// @fn void ScanInfo::FromXml( string input )
///
/// @brief  Initializes this object from the given from XML. 
///
/// This function reconstructs object back from the XML generated by the @b ToXml function
///
/// @param  input - The input XML. 
////////////////////////////////////////////////////////////////////////////////////////////////////
void ScanInfo::FromXml( string input )
{
    StrStream st(input.c_str());
    TagScanner sc(st);

    LOG4CXX_TRACE(iLogger::GetLogger(), "ScanInfo::FromXml - string");
    FromXml(sc);
}

void ScanInfo::FromXml( TagScanner& sc, int token /*= -1 */ )
{
    int pos;
    int parseLevel = 0;
    bool inParsing = true;
    string name, val, dat;

    LOG4CXX_TRACE(iLogger::GetLogger(), "ScanInfo::FromXml - TagScanner");
    while (inParsing)
    {
        pos = sc.GetPos();
        if (token == -1) {
            token = sc.GetToken();
        }
        switch(token)
        {
        case wstError:
            LOG4CXX_WARN(iLogger::GetLogger(), "ScanInfo::FromXml parsing error");
            inParsing = false;
            break;
        case wstEof:
            LOG4CXX_TRACE(iLogger::GetLogger(), "ScanInfo::FromXml - EOF");
            inParsing = false;
            break;
        case wstTagStart:
            name = sc.GetTagName();
            if (parseLevel == 0)
            {
                if (iequals(name, "scan"))
                {
                    parseLevel = 1;
                    dat = "";
                }
                else {
                    LOG4CXX_WARN(iLogger::GetLogger(), "ScanInfo::FromXml unexpected tagStart: " << name);
                    inParsing = false;
                }
                break;
            }
            if (parseLevel == 1)
            {
                parseLevel = 2;
                if (iequals(name, "scan_data_list"))
                {
                    parseLevel = 3;
                    scan_data.clear();
                }
                dat = "";
                break;
            }
            if (parseLevel == 3)
            {
                if (iequals(name, "scan_data"))
                {
                    ScanData *scdata = new ScanData;
                    scdata->FromXml(sc, token);
                    scan_data.push_back(scdata);
                    break;
                }
            }
            LOG4CXX_WARN(iLogger::GetLogger(), "ScanInfo::FromXml unexpected tagStart: " << name);
            inParsing = false;
            break;
        case wstTagEnd:
            name = sc.GetTagName();
            if (parseLevel == 1)
            {
                if (iequals(name, "scan"))
                {
                    parseLevel = 0;
                    dat = "";
                    inParsing = false;
                }
                else {
                    LOG4CXX_WARN(iLogger::GetLogger(), "ScanInfo::FromXml unexpected wstTagEnd: " << name);
                    inParsing = false;
                }
            }
            if (parseLevel == 2)
            {
                dat = UnscreenXML(dat);
                if (iequals(name, "object"))
                {
                    objectID = dat;
                }
                if (iequals(name, "profile"))
                {
                    profileID = dat;
                }
                if (iequals(name, "start_time"))
                {
                    try {
                        startTime = posix_time::time_from_string(dat);
                    } catch (...) {
                        startTime = posix_time::not_a_date_time;
                    }
                }
                if (iequals(name, "finish_time"))
                {
                    try {
                        finishTime = posix_time::time_from_string(dat);
                    } catch (...) {
                        finishTime = posix_time::not_a_date_time;
                    }
                }
                if (iequals(name, "ping_time"))
                {
                    try {
                        pingTime = posix_time::time_from_string(dat);
                    } catch (...) {
                        pingTime = posix_time::not_a_date_time;
                    }
                }
                if (iequals(name, "status"))
                {
                    status = (weScanStatus)boost::lexical_cast<int>(dat);
                }
                parseLevel = 1;
            }
            if (parseLevel == 3)
            {
                if (iequals(name, "scan_data_list"))
                {
                    parseLevel = 1;
                }
            }
            break;
        case wstAttr:
            name = sc.GetAttrName();
            val = sc.GetValue();
            val = UnscreenXML(val);
            if (parseLevel == 1)
            {
                if (iequals(name, "id"))
                {
                    scanID = val;
                }
            }
            break;
        case wstWord: 
        case wstSpace:
            dat += sc.GetValue();
            break;
        default:
            break;
        }
        token = -1;
    }
}

ScanData* ScanInfo::GetScanData( const string& baseUrl, const string& realUrl )
{
    ScanData* retval = NULL;

    for (size_t i = 0; i < scan_data.size(); i++) {
        if (scan_data[i]->requestedURL == baseUrl &&
            scan_data[i]->realURL == realUrl)
        {
            LOG4CXX_DEBUG(iLogger::GetLogger(), "WeTask::GetScanData - found existing ScanData");
            retval = scan_data[i];
            break;
        }
    }
    if (retval == NULL)
    {
        LOG4CXX_DEBUG(iLogger::GetLogger(), "WeTask::GetScanData new ScanData");
        retval = new ScanData;
        retval->respCode = 0;
        retval->downloadTime = -1;
        retval->dataSize = -1;
        retval->requestedURL = baseUrl;
        retval->realURL = realUrl;
    }
    return retval;
}

void ScanInfo::SetScanData( ScanData* scData )
{
    size_t i;

    for (i = 0; i < scan_data.size(); i++) {
        if (scan_data[i] == scData)
        {
            LOG4CXX_DEBUG(iLogger::GetLogger(), "WeTask::SetScanData - found existing ScanData");
            break;
        }
    }
    if (i == scan_data.size()) {
        LOG4CXX_DEBUG(iLogger::GetLogger(), "WeTask::SetScanData add ScanData to list");
        scan_data.push_back(scData);
    }
}
std::string ScanData::ToXml( void )
{
    string retval;
    string strData;

    retval = "";

    LOG4CXX_TRACE(iLogger::GetLogger(), "ScanData::ToXml");
    retval += "<scan_data id='" + ScreenXML(dataID) + "'>\n";
    retval += "  <scan_id>" + ScreenXML(scanID) + "</scan_id>\n";
    retval += "  <parent>" + ScreenXML(parentID) + "</parent>\n";
    retval += "  <req_url>" + ScreenXML(requestedURL) + "</req_url>\n";
    retval += "  <final_url>" + ScreenXML(realURL) + "</final_url>\n";
    retval += "  <response>" + boost::lexical_cast<string>(respCode) + "</response>\n";
    retval += "  <data_size>" + boost::lexical_cast<string>(dataSize) + "</data_size>\n";
    retval += "  <download_time>" + boost::lexical_cast<string>(downloadTime) + "</download_time>\n";
    retval += "</scan_data>\n";
    return retval;

}

void ScanData::FromXml( string input )
{
    StrStream st(input.c_str());
    TagScanner sc(st);

    LOG4CXX_TRACE(iLogger::GetLogger(), "ScanData::FromXml - string");
    FromXml(sc);
}

void ScanData::FromXml( TagScanner& sc, int token /*= -1 */ )
{
    int pos;
    int parseLevel = 0;
    bool inParsing = true;
    string name, val, dat;

    LOG4CXX_TRACE(iLogger::GetLogger(), "ScanData::FromXml - TagScanner");
    while (inParsing)
    {
        pos = sc.GetPos();
        if (token == -1) {
            token = sc.GetToken();
        }
        switch(token)
        {
        case wstError:
            LOG4CXX_WARN(iLogger::GetLogger(), "ScanData::FromXml parsing error");
            inParsing = false;
            break;
        case wstEof:
            LOG4CXX_TRACE(iLogger::GetLogger(), "ScanData::FromXml - EOF");
            inParsing = false;
            break;
        case wstTagStart:
            name = sc.GetTagName();
            if (parseLevel == 0)
            {
                if (iequals(name, "scan_data"))
                {
                    parseLevel = 1;
                    dat = "";
                }
                else {
                    LOG4CXX_WARN(iLogger::GetLogger(), "ScanData::FromXml unexpected tagStart: " << name);
                    inParsing = false;
                }
                break;
            }
            if (parseLevel == 1)
            {
                parseLevel = 2;
                dat = "";
                break;
            }
            LOG4CXX_WARN(iLogger::GetLogger(), "ScanData::FromXml unexpected tagStart: " << name);
            inParsing = false;
            break;
        case wstTagEnd:
            name = sc.GetTagName();
            if (parseLevel == 1)
            {
                if (iequals(name, "scan_data"))
                {
                    parseLevel = 0;
                    dat = "";
                    inParsing = false;
                }
                else {
                    LOG4CXX_WARN(iLogger::GetLogger(), "ScanData::FromXml unexpected wstTagEnd: " << name);
                    inParsing = false;
                }
            }
            if (parseLevel == 2)
            {
                dat = UnscreenXML(dat);
                if (iequals(name, "scan_id"))
                {
                    scanID = dat;
                }
                if (iequals(name, "parent"))
                {
                    parentID = dat;
                }
                if (iequals(name, "req_url"))
                {
                    requestedURL = dat;
                }
                if (iequals(name, "final_url"))
                {
                    realURL = dat;
                }
                if (iequals(name, "response"))
                {
                    respCode = boost::lexical_cast<int>(dat);
                }
                if (iequals(name, "data_size"))
                {
                    dataSize = boost::lexical_cast<int>(dat);
                }
                if (iequals(name, "download_time"))
                {
                    downloadTime = boost::lexical_cast<int>(dat);
                }
                parseLevel = 1;
            }
            break;
        case wstAttr:
            name = sc.GetAttrName();
            val = sc.GetValue();
            val = UnscreenXML(val);
            if (parseLevel == 1)
            {
                if (iequals(name, "id"))
                {
                    dataID = val;
                }
            }
            break;
        case wstWord: 
        case wstSpace:
            dat += sc.GetValue();
            break;
        default:
            break;
        }
        token = -1;
    }
}

} // namespace webEngine
